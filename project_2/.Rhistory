Q_old <- dnorm(mu0_old, ysum0/N_0, (sigma_0^2)/N_0, log = TRUE)
print(Q_old)
Q_new <- dnorm(mu0_new, ysum0/N_0, (sigma_0^2)/N_0, log = TRUE)
print(Q_new)
f_old <- ftheta(mu0_old, mu_1, sigma_0, sigma_1)*fygivenxphi(mu0_old, mu_0, sigma_0^2)
print(f_old)
f_new <- ftheta(mu0_new, mu_1, sigma_0, sigma_1)*fygivenxphi(mu0_new, mu_0, sigma_0^2)
print(f_new)
ratio <- (f_new*Q_old)/(f_old*Q_new)
print(ratio)
acc <- min(1, ratio)
u <- runif(1)
if (u < acc){
res <- mu0_new
} else {
res <- mu0_new
}
return(res)
}
Q_old <- dnorm(mu0_old, ysum0/N_0, (sigma_0^2)/N_0, log = TRUE)
print(Q_old)
Q_new <- dnorm(mu0_new, ysum0/N_0, (sigma_0^2)/N_0, log = TRUE)
# Propose random new mu0
mu0_new <- rnorm(1, ysum0/N_0, (sigma_0^2)/N_0)
Q_old <- dnorm(mu0_old, ysum0/N_0, (sigma_0^2)/N_0, log = TRUE)
print(Q_old)
Q_new <- dnorm(mu0_new, ysum0/N_0, (sigma_0^2)/N_0, log = TRUE)
print(Q_new)
?dnorm
# Propose random new mu0
mu0_new <- rnorm(1, ysum0/N_0, sqrt((sigma_0^2)/N_0))
Q_old <- dnorm(mu0_old, ysum0/N_0, sqrt((sigma_0^2)/N_0), log = TRUE)
print(Q_old)
Q_new <- dnorm(mu0_new, ysum0/N_0, sqrt((sigma_0^2)/N_0), log = TRUE)
print(Q_new)
f_old <- ftheta(mu0_old, mu_1, sigma_0, sigma_1)*fygivenxphi(mu0_old, mu_0, sigma_0^2)
print(f_old)
f_old <- log(ftheta(mu0_old, mu_1, sigma_0, sigma_1)*fygivenxphi(mu0_old, mu_0, sigma_0))
print(f_old)
f_new <- log(ftheta(mu0_new, mu_1, sigma_0, sigma_1)*fygivenxphi(mu0_new, mu_0, sigma_0))
print(f_new)
ratio <- (f_new*Q_old)/(f_old*Q_new)
print(ratio)
ftheta(mu0_old, mu_1, sigma_0, sigma_1)
fygivenxphi(mu0_old, mu_0, sigma_0)
# Count number of 0s or ones in x
# and return sum of corresponding values in y
fcount <- function(x, y, bool){
nrows <- dim(x)[1]
ncols <- dim(x)[2]
count <- 0
yval = 0
for (i in 1:nrows){
for(j in 1:ncols){
if (x[i,j] == bool){
count <- count + 1
yval[count] <- y[i,j]
}
}
}
ysum <- sum(yval)
res <- data.frame(count, ysum)
return(res)
}
# b) For mu_0
res0 <- fcount(x,y,0)
N_0 <- res0$count
ysum0 <- res0$ysum
mu0_old <- mu_0
## Acceptance probability
# ---- Utilities --- #
ftheta <- function(mu_0, mu_1, sigma_0, sigma_1){
if (sigma_0 <= sigma_1 && mu_0 < mu_1){
res <- (((mu_1-mu_0)^3)/(sigma_0^3*sigma_1^2))*exp(-(((mu_1-mu_0)/(sqrt(sigma_0*sigma_1)))+sqrt(sigma_1/sigma_0)))
}
else if (sigma_0 > sigma_1 && mu_0 < mu_1){
res <- (((mu_1-mu_0)^3)/(sigma_0^2*sigma_1^3))*exp(-(((mu_1-mu_0)/(sqrt(sigma_0*sigma_1)))+sqrt(sigma_0/sigma_1)))
}
return(res)
}
fygivenxphi <- function(val, mu, sigma){
return(dnorm(val, mu, sigma))
}
# --- Main---- #
muzero <- function(N0, ysum0, sigma_0, mu0_old){
# Propose random new mu0
mu0_new <- rnorm(1, ysum0/N_0, sqrt((sigma_0^2)/N_0))
Q_old <- dnorm(mu0_old, ysum0/N_0, sqrt((sigma_0^2)/N_0), log = TRUE)
print(Q_old)
Q_new <- dnorm(mu0_new, ysum0/N_0, sqrt((sigma_0^2)/N_0), log = TRUE)
print(Q_new)
f_old <- log(ftheta(mu0_old, mu_1, sigma_0, sigma_1)*fygivenxphi(mu0_old, mu_0, sigma_0))
ftheta(mu0_old, mu_1, sigma_0, sigma_1)
fygivenxphi(mu0_old, mu_0, sigma_0)
print(f_old)
f_new <- log(ftheta(mu0_new, mu_1, sigma_0, sigma_1)*fygivenxphi(mu0_new, mu_0, sigma_0))
print(f_new)
ratio <- (f_new*Q_old)/(f_old*Q_new)
print(ratio)
acc <- min(1, ratio)
u <- runif(1)
if (u < acc){
res <- mu0_new
} else {
res <- mu0_new
}
return(res)
}
test0 <- muzero(N_0, ysum0, sigma_0, mu0_old)
exp(-24)
# --- Main---- #
muzero <- function(N0, ysum0, sigma_0, mu0_old){
# Propose random new mu0
mu0_new <- rnorm(1, ysum0/N_0, sqrt((sigma_0^2)/N_0))
Q_old <- dnorm(mu0_old, ysum0/N_0, sqrt((sigma_0^2)/N_0), log = TRUE)
#print(Q_old)
Q_new <- dnorm(mu0_new, ysum0/N_0, sqrt((sigma_0^2)/N_0), log = TRUE)
#print(Q_new)
f_old <- log(ftheta(mu0_old, mu_1, sigma_0, sigma_1)*fygivenxphi(mu0_old, mu_0, sigma_0))
#ftheta(mu0_old, mu_1, sigma_0, sigma_1)
#fygivenxphi(mu0_old, mu_0, sigma_0)
#print(f_old)
f_new <- log(ftheta(mu0_new, mu_1, sigma_0, sigma_1)*fygivenxphi(mu0_new, mu_0, sigma_0))
#print(f_new)
# NB: Ratio on log scale
ratio <- (f_new*Q_old)/(f_old*Q_new)
print(ratio)
acc <- min(0, ratio) # on log scale
u <- log(runif(1))
if (u < acc){
res <- mu0_new
} else {
res <- mu0_new
}
return(res)
}
test0 <- muzero(N_0, ysum0, sigma_0, mu0_old)
# NB: Ratio on log scale
ratio <- (f_new*Q_old)/(f_old*Q_new)
print(ratio)
# Propose random new mu0
mu0_new <- rnorm(1, ysum0/N_0, sqrt((sigma_0^2)/N_0))
Q_old <- dnorm(mu0_old, ysum0/N_0, sqrt((sigma_0^2)/N_0), log = TRUE)
#print(Q_old)
Q_new <- dnorm(mu0_new, ysum0/N_0, sqrt((sigma_0^2)/N_0), log = TRUE)
#print(Q_new)
f_old <- log(ftheta(mu0_old, mu_1, sigma_0, sigma_1)*fygivenxphi(mu0_old, mu_0, sigma_0))
#ftheta(mu0_old, mu_1, sigma_0, sigma_1)
#fygivenxphi(mu0_old, mu_0, sigma_0)
#print(f_old)
f_new <- log(ftheta(mu0_new, mu_1, sigma_0, sigma_1)*fygivenxphi(mu0_new, mu_0, sigma_0))
# NB: Ratio on log scale
ratio <- (f_new*Q_old)/(f_old*Q_new)
print(ratio)
acc <- min(0, ratio) # on log scale
print(acc)
u <- log(runif(1))
print(u)
if (u < acc){
res <- mu0_new
} else {
res <- mu0_new
}
print(res)
# --- Main---- #
muzero <- function(N_0, ysum0, sigma_0, mu0_old){
# Propose random new mu0
mu0_new <- rnorm(1, ysum0/N_0, sqrt((sigma_0^2)/N_0))
Q_old <- dnorm(mu0_old, ysum0/N_0, sqrt((sigma_0^2)/N_0), log = TRUE)
#print(Q_old)
Q_new <- dnorm(mu0_new, ysum0/N_0, sqrt((sigma_0^2)/N_0), log = TRUE)
#print(Q_new)
f_old <- log(ftheta(mu0_old, mu_1, sigma_0, sigma_1)*fygivenxphi(mu0_old, mu_0, sigma_0))
#ftheta(mu0_old, mu_1, sigma_0, sigma_1)
#fygivenxphi(mu0_old, mu_0, sigma_0)
#print(f_old)
f_new <- log(ftheta(mu0_new, mu_1, sigma_0, sigma_1)*fygivenxphi(mu0_new, mu_0, sigma_0))
#print(f_new)
# NB: Ratio on log scale
ratio <- (f_new*Q_old)/(f_old*Q_new)
print(ratio)
acc <- min(0, ratio) # on log scale
print(acc)
u <- log(runif(1))
print(u)
if (u < acc){
res <- mu0_new
} else {
res <- mu0_new
}
print(res)
return(res)
}
test0 <- muzero(N_0, ysum0, sigma_0, mu0_old)
muone <- function(N_1, ysum1, sigma_1, mu1_old){
# Propose random new mu0
mu1_new <- rnorm(1, ysum1/N_1, sqrt((sigma_1^2)/N_1))
Q_old <- dnorm(mu1_old, ysum1/N_1, sqrt((sigma_1^2)/N_1), log = TRUE)
#print(Q_old)
Q_new <- dnorm(mu1_new, ysum1/N_1, sqrt((sigma_1^2)/N_1), log = TRUE)
#print(Q_new)
f_old <- log(ftheta(mu_0, mu1_old, sigma_0, sigma_1)*fygivenxphi(mu1_old, mu_1, sigma_1))
#ftheta(mu0_old, mu_1, sigma_0, sigma_1)
#fygivenxphi(mu0_old, mu_0, sigma_0)
#print(f_old)
f_new <- log(ftheta(mu_0, mu1_new, sigma_0, sigma_1)*fygivenxphi(mu1_new, mu_1, sigma_1))
#print(f_new)
# NB: Ratio on log scale
ratio <- (f_new*Q_old)/(f_old*Q_new)
print(ratio)
acc <- min(0, ratio) # on log scale
print(acc)
u <- log(runif(1))
print(u)
if (u < acc){
res <- mu1_new
} else {
res <- mu1_new
}
print(res)
return(res)
}
test1 <- muone(N_1, ysum1, sigma_1, mu1_old)
# For mu_1
res <- fcount(x,y,1)
N_1 <- res$count
ysum1 <- res$ysum
mu1_old <- mu_1
muone <- function(N_1, ysum1, sigma_1, mu1_old){
# Propose random new mu0
mu1_new <- rnorm(1, ysum1/N_1, sqrt((sigma_1^2)/N_1))
Q_old <- dnorm(mu1_old, ysum1/N_1, sqrt((sigma_1^2)/N_1), log = TRUE)
#print(Q_old)
Q_new <- dnorm(mu1_new, ysum1/N_1, sqrt((sigma_1^2)/N_1), log = TRUE)
#print(Q_new)
f_old <- log(ftheta(mu_0, mu1_old, sigma_0, sigma_1)*fygivenxphi(mu1_old, mu_1, sigma_1))
#ftheta(mu0_old, mu_1, sigma_0, sigma_1)
#fygivenxphi(mu0_old, mu_0, sigma_0)
#print(f_old)
f_new <- log(ftheta(mu_0, mu1_new, sigma_0, sigma_1)*fygivenxphi(mu1_new, mu_1, sigma_1))
#print(f_new)
# NB: Ratio on log scale
ratio <- (f_new*Q_old)/(f_old*Q_new)
print(ratio)
acc <- min(0, ratio) # on log scale
print(acc)
u <- log(runif(1))
print(u)
if (u < acc){
res <- mu1_new
} else {
res <- mu1_new
}
print(res)
return(res)
}
test1 <- muone(N_1, ysum1, sigma_1, mu1_old)
test1 <- muone(N_1, ysum1, sigma_1, mu1_old)
muone <- function(N_1, ysum1, sigma_1, mu1_old){
# Propose random new mu0
mu1_new <- rnorm(1, ysum1/N_1, sqrt((sigma_1^2)/N_1))
Q_old <- dnorm(mu1_old, ysum1/N_1, sqrt((sigma_1^2)/N_1), log = TRUE)
#print(Q_old)
Q_new <- dnorm(mu1_new, ysum1/N_1, sqrt((sigma_1^2)/N_1), log = TRUE)
#print(Q_new)
f_old <- log(ftheta(mu_0, mu1_old, sigma_0, sigma_1)*fygivenxphi(mu1_old, mu_1, sigma_1))
#ftheta(mu0_old, mu_1, sigma_0, sigma_1)
#fygivenxphi(mu0_old, mu_0, sigma_0)
#print(f_old)
f_new <- log(ftheta(mu_0, mu1_new, sigma_0, sigma_1)*fygivenxphi(mu1_new, mu_1, sigma_1))
#print(f_new)
# NB: Ratio on log scale
ratio <- (f_new*Q_old)/(f_old*Q_new)
#print(ratio)
acc <- min(0, ratio) # on log scale
#print(acc)
u <- log(runif(1))
#print(u)
if (u < acc){
res <- mu1_new
} else {
res <- mu1_new
}
#print(res)
return(res)
}
test1 <- muone(N_1, ysum1, sigma_1, mu1_old)
test1
mu1_old
rm(list = ls())
x_prior = function(x) {
nrows = dim(x)[1]
ncolumns = dim(x)[2]
indicator_vec = matrix(c(0), nrow = nrows, ncol = ncolumns)
for (i in 1:nrows) {
for(j in 1:ncolumns) {
indicator_vec[i,j] = indicator_x(x,i,j)
}
}
return(sum(indicator_vec))
}
indicator_x = function(x,i,j) {
nrows = dim(x)[1]
ncolumns = dim(x)[2]
if (i > 1 && i < nrows && j > 1 && j < ncolumns) {
right = x[i,j] == x[i+1,j]
left = x[i,j] == x[i-1,j]
up = x[i,j] == x[i,j-1]
down = x[i,j] == x[i,j+1]
indicator = right + left + up + down
}
else if (i == 1 && j == 1) {
right = x[i,j] == x[i+1,j]
down = x[i,j] == x[i,j+1]
indicator = right + down
}
else if (i == 1 && j == ncolumns) {
right = x[i,j] == x[i+1,j]
up = x[i,j] == x[i,j-1]
indicator = right + up
}
else if (i == nrows && j == 1) {
left = x[i,j] == x[i-1,j]
down = x[i,j] == x[i,j+1]
indicator = left + down
}
else if (i == nrows && j == ncolumns) {
left = x[i,j] == x[i-1,j]
up = x[i,j] == x[i,j-1]
indicator = left + up
}
else if (i == 1) {
right = x[i,j] == x[i+1,j]
up = x[i,j] == x[i,j-1]
down = x[i,j] == x[i,j+1]
indicator = right + up + down
}
else if (i == nrows) {
left = x[i,j] == x[i-1,j]
up = x[i,j] == x[i,j-1]
down = x[i,j] == x[i,j+1]
indicator = left + up + down
}
else if (j == 1) {
right = x[i,j] == x[i+1,j]
left = x[i,j] == x[i-1,j]
down = x[i,j] == x[i,j+1]
indicator = right + left + down
}
else if (j == ncolumns) {
right = x[i,j] == x[i+1,j]
left = x[i,j] == x[i-1,j]
up = x[i,j] == x[i,j-1]
indicator = right + left + up
}
return(indicator)
}
y = read.table("./image.txt", header = FALSE, sep = " ")
nrows = dim(y)[1]
ncolumns = dim(y)[2]
sigma_0 = 0.5
sigma_1 = 0.5
mu_0 = -1
mu_1 = 2
beta = 1
x = matrix(rbinom(nrows * ncolumns, 1, 0.5), ncol = ncolumns, nrow = nrows)
i = ceiling(nrows*runif(1))
j = ceiling(ncolumns*runif(1))
x_prop = 1 - x[i,j]
x_new = x
x_new[i,j] = x_prop
I = x_prior(x)
I_prop = x_prior(x_new)
ising = exp(beta*(I_prop-I))
if (x[i,j] == 0) {
normal = sigma_0/sigma_1 * exp(-1/(2*sigma_1^2)*(y[i,j]-mu_1)^2 + 1/(2*sigma_0)*(y[i,j]-mu_0)^2)
}
if(x[i,j] == 1){
normal = sigma_1/sigma_0 * exp(-1/(2*sigma_0^2)*(y[i,j]-mu_0)^2 + 1/(2*sigma_1)*(y[i,j]-mu_1)^2)
}
fratio = normal * ising
alpha = min(1,fratio)
u = runif(1)
if (u < alpha) {
x[i,j] = x_prop
}
# Count number of 0s or ones in x
# and return sum of corresponding values in y
fcount <- function(x, y, bool){
nrows <- dim(x)[1]
ncols <- dim(x)[2]
count <- 0
yval = 0
for (i in 1:nrows){
for(j in 1:ncols){
if (x[i,j] == bool){
count <- count + 1
yval[count] <- y[i,j]
}
}
}
ysum <- sum(yval)
res <- data.frame(count, ysum)
return(res)
}
# b) For mu_0
res0 <- fcount(x,y,0)
N_0 <- res0$count
ysum0 <- res0$ysum
mu0_old <- mu_0
## Acceptance probability
# ---- Utilities --- #
ftheta <- function(mu_0, mu_1, sigma_0, sigma_1){
if (sigma_0 <= sigma_1 && mu_0 < mu_1){
res <- (((mu_1-mu_0)^3)/(sigma_0^3*sigma_1^2))*exp(-(((mu_1-mu_0)/(sqrt(sigma_0*sigma_1)))+sqrt(sigma_1/sigma_0)))
}
else if (sigma_0 > sigma_1 && mu_0 < mu_1){
res <- (((mu_1-mu_0)^3)/(sigma_0^2*sigma_1^3))*exp(-(((mu_1-mu_0)/(sqrt(sigma_0*sigma_1)))+sqrt(sigma_0/sigma_1)))
}
return(res)
}
fygivenxphi <- function(val, mu, sigma){
return(dnorm(val, mu, sigma))
}
# --- Main---- #
muzero <- function(N_0, ysum0, sigma_0, mu0_old){
# Propose random new mu0
mu0_new <- rnorm(1, ysum0/N_0, sqrt((sigma_0^2)/N_0))
Q_old <- dnorm(mu0_old, ysum0/N_0, sqrt((sigma_0^2)/N_0), log = TRUE)
#print(Q_old)
Q_new <- dnorm(mu0_new, ysum0/N_0, sqrt((sigma_0^2)/N_0), log = TRUE)
#print(Q_new)
f_old <- log(ftheta(mu0_old, mu_1, sigma_0, sigma_1)*fygivenxphi(mu0_old, mu_0, sigma_0))
#ftheta(mu0_old, mu_1, sigma_0, sigma_1)
#fygivenxphi(mu0_old, mu_0, sigma_0)
#print(f_old)
f_new <- log(ftheta(mu0_new, mu_1, sigma_0, sigma_1)*fygivenxphi(mu0_new, mu_0, sigma_0))
#print(f_new)
# NB: Ratio on log scale
ratio <- (f_new*Q_old)/(f_old*Q_new)
#print(ratio)
acc <- min(0, ratio) # on log scale
#print(acc)
u <- log(runif(1))
#print(u)
if (u < acc){
res <- mu0_new
} else {
res <- mu0_new
}
#print(res)
return(res)
}
test0 <- muzero(N_0, ysum0, sigma_0, mu0_old)
# For mu_1
res <- fcount(x,y,1)
N_1 <- res$count
ysum1 <- res$ysum
mu1_old <- mu_1
muone <- function(N_1, ysum1, sigma_1, mu1_old){
# Propose random new mu0
mu1_new <- rnorm(1, ysum1/N_1, sqrt((sigma_1^2)/N_1))
Q_old <- dnorm(mu1_old, ysum1/N_1, sqrt((sigma_1^2)/N_1), log = TRUE)
#print(Q_old)
Q_new <- dnorm(mu1_new, ysum1/N_1, sqrt((sigma_1^2)/N_1), log = TRUE)
#print(Q_new)
f_old <- log(ftheta(mu_0, mu1_old, sigma_0, sigma_1)*fygivenxphi(mu1_old, mu_1, sigma_1))
#ftheta(mu0_old, mu_1, sigma_0, sigma_1)
#fygivenxphi(mu0_old, mu_0, sigma_0)
#print(f_old)
f_new <- log(ftheta(mu_0, mu1_new, sigma_0, sigma_1)*fygivenxphi(mu1_new, mu_1, sigma_1))
#print(f_new)
# NB: Ratio on log scale
ratio <- (f_new*Q_old)/(f_old*Q_new)
#print(ratio)
acc <- min(0, ratio) # on log scale
#print(acc)
u <- log(runif(1))
#print(u)
if (u < acc){
res <- mu1_new
} else {
res <- mu1_new
}
#print(res)
return(res)
}
test1 <- muone(N_1, ysum1, sigma_1, mu1_old)
test1
test0
y
hist(y)
typeof(y)
hist(y[,1])
hist(as.data.frame(y))
as.data.frame(y)
huh <- as.data.frame(y)
hist(huh)
max(y)
min(y)
typeof(y)
head(y)
View(y)
View(y)
huh <- as.vector(y)
huh
dim(huh)
hist(huh)
?rep
hist(1)
hist(2)
hist(78)
