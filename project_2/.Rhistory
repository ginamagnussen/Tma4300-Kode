fraction = (logterm1 - logterm2 + logterm3 - logterm4 + logterm5)
fraction_vec[i] = fraction
}
else {
fraction = -Inf
}
alpha = min(0,fraction)
u = log(runif(1))
if (u < alpha) { # if true accept new proposal
N0[i+1] = N0_prop
N1[i+1] = N1_prop
t[i+1] = t_prop
counterAccRate = counterAccRate + 1
}
else { #or if false, keep the old state
N0[i+1] = N0[i]
N1[i+1] = N1[i]
t[i+1] = t[i]
}
#sample beta
beta[i+1] = rinvgamma(1,shape = 4, scale = 1/(lambda0[i] + lambda1[i] + 1))
#sample lambda
lambda0[i+1] = rgamma(1,shape = N0[i+1] + 2,scale = 1/((t[i+1]-t_0)+1/beta[i+1]))
lambda1[i+1] = rgamma(1,shape = N1[i+1] + 2,scale = 1/((t_2-t[i+1]) + 1/beta[i+1]))
}
counterAccRate/n
iter = seq(1,n,1)
plot(iter,t)
ggplot(data = as.data.frame(t), aes(x = iter, y = t) ) + geom_path()
mean(lambda0)
mean(lambda1)
hist(t)
# intital cond
n = 100000
t_0 = coal[1,]
t_2 = coal[191,]
lambda0 = rep(0,n)
lambda1 = rep(0,n)
beta = rep(0,n)
beta[1] = 1
t= rep(0,n)
sigma = (t_2-t_0)/7.5
#sigma = 8
t[1] = (t_0+t_2)/2
lambda0[1] = 3
lambda1[1] =1
N0 = rep(0,n)
N1 = rep(0,n)
index = divide_data(t[1])
N0[1] = index
N1[1] = 189-index
counterAccRate = 0
fraction_vec = rep(0,1)
#Metropolis Hastings, we know how to sample beta, and lambda, and always accept the proposals. For t, using random walk proposals.
for (i in 1:(n-1)) {
#i = 1
t_prop = rnorm(1,t[i],sigma)
#find split of N_prop
index = divide_data(t_prop)
N0_prop = index
N1_prop = 189-(index)
t_out_of_range = (t_prop > t_2) || (t_prop < t_0)
#find acceptance probability
if (!t_out_of_range) {
logterm1 = N0_prop*(log(lambda0[i]) + log(t_prop-t_0)) + N1_prop*(log(lambda1[i]) + log(t_2-t_prop))
logterm2 = N0[i]*(log(lambda0[i]) + log(t[i]-t_0)) + N1[i]*(log(lambda1[i]) + log(t_2-t[i]))
logterm3 = (lambda1[i] -lambda0[i])*(t_prop-t[i])
logterm4 = lfactorial(N0_prop) + lfactorial(N1_prop)
logterm5 = lfactorial(N0[i]) + lfactorial(N1[i])
fraction = (logterm1 - logterm2 + logterm3 - logterm4 + logterm5)
fraction_vec[i] = fraction
}
else {
fraction = -Inf
}
alpha = min(0,fraction)
u = log(runif(1))
if (u < alpha) { # if true accept new proposal
N0[i+1] = N0_prop
N1[i+1] = N1_prop
t[i+1] = t_prop
counterAccRate = counterAccRate + 1
}
else { #or if false, keep the old state
N0[i+1] = N0[i]
N1[i+1] = N1[i]
t[i+1] = t[i]
}
#sample beta
beta[i+1] = rinvgamma(1,shape = 4, scale = 1/(lambda0[i] + lambda1[i] + 1))
#sample lambda
lambda0[i+1] = rgamma(1,shape = N0[i+1] + 2,scale = 1/((t[i+1]-t_0)+1/beta[i+1]))
lambda1[i+1] = rgamma(1,shape = N1[i+1] + 2,scale = 1/((t_2-t[i+1]) + 1/beta[i+1]))
}
counterAccRate/n
iter = seq(1,n,1)
plot(iter,t)
ggplot(data = as.data.frame(t), aes(x = iter, y = t) ) + geom_path()
mean(lambda0)
mean(lambda1)
hist(t)
# intital cond
n = 100000
t_0 = coal[1,]
t_2 = coal[191,]
lambda0 = rep(0,n)
lambda1 = rep(0,n)
beta = rep(0,n)
beta[1] = 1
t= rep(0,n)
sigma = (t_2-t_0)/7
#sigma = 8
t[1] = (t_0+t_2)/2
lambda0[1] = 3
lambda1[1] =1
N0 = rep(0,n)
N1 = rep(0,n)
index = divide_data(t[1])
N0[1] = index
N1[1] = 189-index
counterAccRate = 0
fraction_vec = rep(0,1)
#Metropolis Hastings, we know how to sample beta, and lambda, and always accept the proposals. For t, using random walk proposals.
for (i in 1:(n-1)) {
#i = 1
t_prop = rnorm(1,t[i],sigma)
#find split of N_prop
index = divide_data(t_prop)
N0_prop = index
N1_prop = 189-(index)
t_out_of_range = (t_prop > t_2) || (t_prop < t_0)
#find acceptance probability
if (!t_out_of_range) {
logterm1 = N0_prop*(log(lambda0[i]) + log(t_prop-t_0)) + N1_prop*(log(lambda1[i]) + log(t_2-t_prop))
logterm2 = N0[i]*(log(lambda0[i]) + log(t[i]-t_0)) + N1[i]*(log(lambda1[i]) + log(t_2-t[i]))
logterm3 = (lambda1[i] -lambda0[i])*(t_prop-t[i])
logterm4 = lfactorial(N0_prop) + lfactorial(N1_prop)
logterm5 = lfactorial(N0[i]) + lfactorial(N1[i])
fraction = (logterm1 - logterm2 + logterm3 - logterm4 + logterm5)
fraction_vec[i] = fraction
}
else {
fraction = -Inf
}
alpha = min(0,fraction)
u = log(runif(1))
if (u < alpha) { # if true accept new proposal
N0[i+1] = N0_prop
N1[i+1] = N1_prop
t[i+1] = t_prop
counterAccRate = counterAccRate + 1
}
else { #or if false, keep the old state
N0[i+1] = N0[i]
N1[i+1] = N1[i]
t[i+1] = t[i]
}
#sample beta
beta[i+1] = rinvgamma(1,shape = 4, scale = 1/(lambda0[i] + lambda1[i] + 1))
#sample lambda
lambda0[i+1] = rgamma(1,shape = N0[i+1] + 2,scale = 1/((t[i+1]-t_0)+1/beta[i+1]))
lambda1[i+1] = rgamma(1,shape = N1[i+1] + 2,scale = 1/((t_2-t[i+1]) + 1/beta[i+1]))
}
counterAccRate/n
iter = seq(1,n,1)
plot(iter,t)
ggplot(data = as.data.frame(t), aes(x = iter, y = t) ) + geom_path()
mean(lambda0)
mean(lambda1)
hist(t)
ggplot(data = as.data.frame(t), aes(x = iter, y = t) ) + geom_path()
plot(iter,t)
ggplot(data = as.data.frame(t), aes(x = iter, y = t) ) + geom_path()
knitr::opts_chunk$set(echo = TRUE, cache=TRUE, autodep=TRUE)
divide_data = function(t) {
coalEvents = coal[2:190,]
indicator = coalEvents < t
index = sum(indicator)
return (index)
}
# intital conditions
n = 10000
t_0 = coal[1,]
t_2 = coal[191,]
lambda0 = rep(0,n)
lambda1 = rep(0,n)
beta = rep(0,n)
beta[1] = 1
t= rep(0,n)
sigma = (t_2-t_0)/2
t[1] = 1910
lambda0[1] = 3
lambda1[1] =1
N0 = rep(0,n)
N1 = rep(0,n)
index = divide_data(t[1])
N0[1] = index
N1[1] = 189-index
counterAccRate = 0
fraction_vec = rep(0,1)
#Metropolis Hasting
for (i in 1:(n-1)) {
# Generate t from normal
t_prop = rnorm(1,t[i],sigma)
#find split of N_prop
index = divide_data(t_prop)
N0_prop = index
N1_prop = 189-(index)
#lambda prop
lambda0_prop = rgamma(1,shape = N0_prop + 2,scale = 1/((t_prop-t_0)+1/beta[i]))
lambda1_prop = rgamma(1,shape = N1_prop + 2,scale = 1/((t_2-t_prop) + 1/beta[i]))
t_out_of_range = (t_prop > t_2) || (t_prop < t_0)
#find acceptance probability
if (!t_out_of_range) {
#log f1(t,lambda0,lambda1 - proposed state)
logterm1 = N0_prop*log(lambda0_prop*(t_prop-t_0)) + N1_prop*log(lambda1_prop*(t_2-t_prop))
logterm2 = lambda0_prop*(t_prop-t_0) + lambda1_prop*(t_2-t_prop)
logterm3 = lambda0_prop/beta[i] + lambda1_prop/beta[i]
logterm4 = lfactorial(N0_prop) + lfactorial(N1_prop)
logpart1 = logterm1 + logterm2 + logterm3 - logterm4
#log f2(t, lambda0, lambda1 -old state)
logterm5 = N0[i]*log(lambda0[i]*(t[i]-t_0)) + N1[i]*log(lambda1[i]*(t_2-t[i]))
logterm6 = lambda0[i]*(t[i]-t_0) + lambda1[i]*(t_2-t[i])
logterm7 = lambda0[i]/beta[i] + lambda1[i]/beta[i]
logterm8 = lfactorial(N0[i]) + lfactorial(N1[i])
logpart2 = logterm5 + logterm6 + logterm7 - logterm8
#log Q1(t,lambda0, lambda1) - proposed
logpart3 = (N0_prop+1)*log(lambda0_prop) + (N1_prop+1)*log(lambda1_prop) - lambda0_prop*((t_prop-t_0)+1/beta[i]) - lambda1_prop*((t_2-t_prop) + 1/beta[i])
#log Q2(t,lambda0, lambda1) -old state
logpart4 = (N0[i]+1)*log(lambda0[i]) + (N1[i]+1)*log(lambda1[i]) - lambda0[i]*((t[i]-t_0)+1/beta[i]) - lambda1[i]*((t_2-t[i]) + 1/beta[i])
#Combine as log(f1) - log(f2) + log(Q2) - log(Q1)
fraction = (logpart1 - logpart2 - logpart3 + logpart4)
fraction_vec[i] = fraction
}
else {
fraction = -Inf
}
logalpha = min(0,fraction)
u = log(runif(1))
if (u < logalpha) { # if true accept new proposal
N0[i+1] = N0_prop
N1[i+1] = N1_prop
t[i+1] = t_prop
counterAccRate = counterAccRate + 1
lambda0[i+1] = lambda0_prop
lambda1[i+1] = lambda1_prop
}
else { #or if false, keep the old state
N0[i+1] = N0[i]
N1[i+1] = N1[i]
t[i+1] = t[i]
lambda0[i+1] = lambda0[i]
lambda1[i+1] = lambda1[i]
}
#sample beta
beta[i+1] = rinvgamma(1,shape = 4, scale = 1/(lambda0[i] + lambda1[i] + 1))
#sample lambda
lambda0[i+1] = rgamma(1,shape = N0[i+1] + 2,scale = 1/((t[i+1]-t_0)+1/beta[i+1]))
lambda1[i+1] = rgamma(1,shape = N1[i+1] + 2,scale = 1/((t_2-t[i+1]) + 1/beta[i+1]))
}
counterAccRate/n
iter = seq(1,n,1)
plot(iter,t)
ggplot(data = as.data.frame(t), aes(x = iter, y = t) ) + geom_path()
median(lambda0)
median(lambda1)
# intital cond
n = 100000
t_0 = coal[1,]
t_2 = coal[191,]
lambda0 = rep(0,n)
lambda1 = rep(0,n)
beta = rep(0,n)
beta[1] = 1
t= rep(0,n)
sigma = (t_2-t_0)/7
#sigma = 8
t[1] = (t_0+t_2)/2
lambda0[1] = 3
lambda1[1] =1
N0 = rep(0,n)
N1 = rep(0,n)
index = divide_data(t[1])
N0[1] = index
N1[1] = 189-index
counterAccRate = 0
fraction_vec = rep(0,1)
#Metropolis Hastings, we know how to sample beta, and lambda, and always accept the proposals. For t, using random walk proposals.
for (i in 1:(n-1)) {
#i = 1
t_prop = rnorm(1,t[i],sigma)
#find split of N_prop
index = divide_data(t_prop)
N0_prop = index
N1_prop = 189-(index)
t_out_of_range = (t_prop > t_2) || (t_prop < t_0)
#find acceptance probability
if (!t_out_of_range) {
logterm1 = N0_prop*(log(lambda0[i]) + log(t_prop-t_0)) + N1_prop*(log(lambda1[i]) + log(t_2-t_prop))
logterm2 = N0[i]*(log(lambda0[i]) + log(t[i]-t_0)) + N1[i]*(log(lambda1[i]) + log(t_2-t[i]))
logterm3 = (lambda1[i] -lambda0[i])*(t_prop-t[i])
logterm4 = lfactorial(N0_prop) + lfactorial(N1_prop)
logterm5 = lfactorial(N0[i]) + lfactorial(N1[i])
fraction = (logterm1 - logterm2 + logterm3 - logterm4 + logterm5)
fraction_vec[i] = fraction
}
else {
fraction = -Inf
}
alpha = min(0,fraction)
u = log(runif(1))
if (u < alpha) { # if true accept new proposal
N0[i+1] = N0_prop
N1[i+1] = N1_prop
t[i+1] = t_prop
counterAccRate = counterAccRate + 1
}
else { #or if false, keep the old state
N0[i+1] = N0[i]
N1[i+1] = N1[i]
t[i+1] = t[i]
}
#sample beta
beta[i+1] = rinvgamma(1,shape = 4, scale = 1/(lambda0[i] + lambda1[i] + 1))
#sample lambda
lambda0[i+1] = rgamma(1,shape = N0[i+1] + 2,scale = 1/((t[i+1]-t_0)+1/beta[i+1]))
lambda1[i+1] = rgamma(1,shape = N1[i+1] + 2,scale = 1/((t_2-t[i+1]) + 1/beta[i+1]))
}
counterAccRate/n
iter = seq(1,n,1)
plot(iter,t)
ggplot(data = as.data.frame(t), aes(x = iter, y = t) ) + geom_path()
mean(lambda0)
mean(lambda1)
hist(t)
mean(t)
knitr::opts_chunk$set(echo = TRUE)
year = coal[2:190,]
numberOfevents = seq(1,189,1)
plot(year,numberOfevents)
hist)(t)
hist(t)
hist(t)
# intital cond
n = 100000
t_0 = coal[1,]
t_2 = coal[191,]
lambda0 = rep(0,n)
lambda1 = rep(0,n)
beta = rep(0,n)
beta[1] = 1
t= rep(0,n)
sigma = (t_2-t_0)/7
#sigma = 8
t[1] = (t_0+t_2)/2
lambda0[1] = 3
lambda1[1] =1
N0 = rep(0,n)
N1 = rep(0,n)
index = divide_data(t[1])
N0[1] = index
N1[1] = 189-index
counterAccRate = 0
fraction_vec = rep(0,1)
#Metropolis Hastings, we know how to sample beta, and lambda, and always accept the proposals. For t, using random walk proposals.
for (i in 1:(n-1)) {
#i = 1
t_prop = rnorm(1,t[i],sigma)
#find split of N_prop
index = divide_data(t_prop)
N0_prop = index
N1_prop = 189-(index)
t_out_of_range = (t_prop > t_2) || (t_prop < t_0)
#find acceptance probability
if (!t_out_of_range) {
logterm1 = N0_prop*(log(lambda0[i]) + log(t_prop-t_0)) + N1_prop*(log(lambda1[i]) + log(t_2-t_prop))
logterm2 = N0[i]*(log(lambda0[i]) + log(t[i]-t_0)) + N1[i]*(log(lambda1[i]) + log(t_2-t[i]))
logterm3 = (lambda0[i] -lambda1[i])*(t_prop-t[i])
logterm4 = lfactorial(N0_prop) + lfactorial(N1_prop)
logterm5 = lfactorial(N0[i]) + lfactorial(N1[i])
fraction = (logterm1 - logterm2 + logterm3 - logterm4 + logterm5)
fraction_vec[i] = fraction
}
else {
fraction = -Inf
}
alpha = min(0,fraction)
u = log(runif(1))
if (u < alpha) { # if true accept new proposal
N0[i+1] = N0_prop
N1[i+1] = N1_prop
t[i+1] = t_prop
counterAccRate = counterAccRate + 1
}
else { #or if false, keep the old state
N0[i+1] = N0[i]
N1[i+1] = N1[i]
t[i+1] = t[i]
}
#sample beta
beta[i+1] = rinvgamma(1,shape = 4, scale = 1/(lambda0[i] + lambda1[i] + 1))
#sample lambda
lambda0[i+1] = rgamma(1,shape = N0[i+1] + 2,scale = 1/((t[i+1]-t_0)+1/beta[i+1]))
lambda1[i+1] = rgamma(1,shape = N1[i+1] + 2,scale = 1/((t_2-t[i+1]) + 1/beta[i+1]))
}
counterAccRate/n
iter = seq(1,n,1)
plot(iter,t)
ggplot(data = as.data.frame(t), aes(x = iter, y = t) ) + geom_path()
mean(lambda0)
mean(lambda1)
hist(t)
# intital cond
n = 100000
t_0 = coal[1,]
t_2 = coal[191,]
lambda0 = rep(0,n)
lambda1 = rep(0,n)
beta = rep(0,n)
beta[1] = 1
t= rep(0,n)
sigma = (t_2-t_0)/7
#sigma = 8
t[1] = (t_0+t_2)/2
lambda0[1] = 3
lambda1[1] =1
N0 = rep(0,n)
N1 = rep(0,n)
index = divide_data(t[1])
N0[1] = index
N1[1] = 189-index
counterAccRate = 0
fraction_vec = rep(0,1)
#Metropolis Hastings, we know how to sample beta, and lambda, and always accept the proposals. For t, using random walk proposals.
for (i in 1:(n-1)) {
#i = 1
t_prop = rnorm(1,t[i],sigma)
#find split of N_prop
index = divide_data(t_prop)
N0_prop = index
N1_prop = 189-(index)
t_out_of_range = (t_prop > t_2) || (t_prop < t_0)
#find acceptance probability
if (!t_out_of_range) {
logterm1 = N0_prop*(log(lambda0[i]) + log(t_prop-t_0)) + N1_prop*(log(lambda1[i]) + log(t_2-t_prop))
logterm2 = N0[i]*(log(lambda0[i]) + log(t[i]-t_0)) + N1[i]*(log(lambda1[i]) + log(t_2-t[i]))
logterm3 = (lambda1[i] -lambda0[i])*(t_prop-t[i])
logterm4 = lfactorial(N0_prop) + lfactorial(N1_prop)
logterm5 = lfactorial(N0[i]) + lfactorial(N1[i])
fraction = (logterm1 - logterm2 + logterm3 - logterm4 + logterm5)
fraction_vec[i] = fraction
}
else {
fraction = -Inf
}
alpha = min(0,fraction)
u = log(runif(1))
if (u < alpha) { # if true accept new proposal
N0[i+1] = N0_prop
N1[i+1] = N1_prop
t[i+1] = t_prop
counterAccRate = counterAccRate + 1
}
else { #or if false, keep the old state
N0[i+1] = N0[i]
N1[i+1] = N1[i]
t[i+1] = t[i]
}
#sample beta
beta[i+1] = rinvgamma(1,shape = 4, scale = 1/(lambda0[i] + lambda1[i] + 1))
#sample lambda
lambda0[i+1] = rgamma(1,shape = N0[i+1] + 2,scale = 1/((t[i+1]-t_0)+1/beta[i+1]))
lambda1[i+1] = rgamma(1,shape = N1[i+1] + 2,scale = 1/((t_2-t[i+1]) + 1/beta[i+1]))
}
counterAccRate/n
iter = seq(1,n,1)
plot(iter,t)
ggplot(data = as.data.frame(t), aes(x = iter, y = t) ) + geom_path()
mean(lambda0)
mean(lambda1)
ggplot(data = as.data.frame(t), aes(x = iter, y = t) ) + geom_path()
hist(t)
mean(t)
hist(lambda0)
mean(lambda0)
mean(lambda1)
yGrid <- read.table("./image.txt", header = FALSE, sep = " ")
View(yGrid)
y = read.table("./image.txt", header = FALSE, sep = " ")
mean(y)
View(yGrid)
y = read.table("./image.txt", header = FALSE, sep = " ")
runif(1)
runif(1,1,85)
runif(3,1,85)
round(runif(3,1,85))
length(y)
size[y]
siz(y)
size(y)
dim(y)
View(y)
View(y)
y = read.table("./image.txt", header = FALSE, sep = " ")
rows = dim(y)[1]
columns = dim(y)[2]
i = runif(1,1,rows)
j = runif(1,1,columns)
i = round(runif(1,1,rows))
j = round(runif(1,1,columns))
beta = 1
View(y)
