---
output: pdf_document
---

```{r, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r, include=FALSE}
library(invgamma)
library(MASS)
```

```{r}
x_prior = function(x,i,j) {
  nrows = dim(x)[1]
  ncolumns = dim(x)[2]
  sum_1 = indicator_x(x,i,j)
  return(2*sum_1)
}

indicator_x = function(x,i,j) {
  nrows = dim(x)[1]
  ncolumns = dim(x)[2]
  indicator_diff = 0
  if (i > 1) {
    left_0 = x[i,j] == x[i-1,j]
    left_1 = (1-x[i,j]) == x[i-1,j]
    indicator_diff = indicator_diff + (left_1 - left_0)
  }
  if (i < nrows) {
    right_0 = x[i,j] == x[i+1,j]
    right_1 = (1-x[i,j]) == x[i+1,j]
    indicator_diff = indicator_diff + (right_1 - right_0)
  }
  if (j > 1) {
    up_0 = x[i,j] == x[i,j-1]
    up_1 = (1-x[i,j]) == x[i,j-1]
    indicator_diff = indicator_diff + (up_1 - up_0)
  }
  if (j < ncolumns) {
    down_0 = x[i,j] == x[i,j+1]
    down_1 = (1-x[i,j]) == x[i,j+1]
    indicator_diff = indicator_diff + (down_1 - down_0)
  }
  return(indicator_diff)
}
```



```{r}
x_update <- function(times, x, mu_0, mu_1, sigma_0, sigma_1, beta){
  for (it in 1:times) {
    i = ceiling(nrows*runif(1))
    j = ceiling(ncolumns*runif(1))
    x_prop = 1 - x[i,j]
    x_new = x
    x_new[i,j] = x_prop
    I = x_prior(x,i,j)
    ising = beta*I
    if (x[i,j] == 0) {
      #normal = sigma_0/sigma_1 * exp(-1/(2*sigma_1^2)*(y[i,j]-mu_1)^2 + 1/(2*sigma_0)*(y[i,j]-mu_0)^2)
      normal = log(sigma_0) - log(sigma_1) - 1/(2*sigma_1^2)*(y[i,j]-mu_1)^2 + 1/(2*sigma_0)*(y[i,j]-mu_0)^2
    }
    if(x[i,j] == 1){
      #normal = sigma_1/sigma_0 * exp(-1/(2*sigma_0^2)*(y[i,j]-mu_0)^2 + 1/(2*sigma_1)*(y[i,j]-mu_1)^2)
      normal = log(sigma_1) - log(sigma_0) -1/(2*sigma_0^2)*(y[i,j]-mu_0)^2 + 1/(2*sigma_1)*(y[i,j]-mu_1)^2
    }
    fratio = normal + ising
    #print(fratio)
    alpha = min(0,fratio)
    u = log(runif(1))
    if (u < alpha) {
      x[i,j] = x_prop
    }
  }
  return(x)
}

## Acceptance probability

# test1 <- muone(N_1, ysum1, sigma_1, mu1_old)
# test1

muzero = function(N_0, ysum0, sigma_0, mu_0, mu_1) {
  mu_0_prop <- rnorm(1, ysum0/N_0, sqrt((sigma_0^2)/N_0))
  if (mu_0_prop > mu_1) {
    return(mu_0)
  }
  else {
    qfratio = 3*(log(mu_1-mu_0_prop)-log(mu_1-mu_0_prop)) - (mu_0 - mu_0_prop)/sqrt(sigma_0*sigma_1)
    alpha = min(0,qfratio)
    u = log(runif(1))
    if (u < alpha) {
      mu_0 = mu_0_prop
    }
    return(mu_0)
  }
}

muone = function(N_1, ysum1, sigma_1, mu_0, mu_1) {
  mu_1_prop <- rnorm(1, ysum1/N_1, sqrt((sigma_1^2)/N_1))
  if (mu_1_prop < mu_0) {
    return(mu_1)
  }
  else {
    qfratio = 3*(log(mu_1_prop-mu_0) - log(mu_1-mu_0)) - (mu_1_prop - mu_1)/sqrt(sigma_0*sigma_1)
    alpha = min(0,qfratio)
    u = log(runif(1))
    if (u < alpha) {
      mu_1 = mu_1_prop
    }
    return(mu_1)
  }
}
  
# test0 <- muzero(N_0, ysum0, sigma_0, mu0_old)
# test0


```

```{r}
#Acceptance probability for sigma_0
# a_0 = 2.5
# b_0 = 6

sigmazero <- function(a_0, b_0, N_0, mu_0, mu_1, sigma_0, sigma_1){
  sigma_0squared_prop = rinvgamma(1, shape = (3 + N_0/2), scale = 1/(100 + sum((y[x==0]-mu_0)^2)/2))
  sigma_0_prop = sqrt(sigma_0squared_prop)
  #logomega_0 = (2*a_0 + 1)*(log(sigma_0_prop) - log(sigma_0)) + b_0 * (1/sigma_0squared_prop - 1/(sigma_0)^2) - (mu_1-mu_0)/(sqrt(sigma_0_prop*sigma_1)) + (mu_1 - mu_0)/(sqrt(sigma_0*sigma_1))
  if (sigma_0 <= sigma_1 && sigma_0_prop < sigma_1) {
    case_0 = 3*(log(sigma_0)-log(sigma_0_prop)) - sqrt(sigma_1/sigma_0_prop) + sqrt(sigma_1/sigma_0)
  } else if (sigma_0 <= sigma_1 && sigma_0_prop > sigma_1) {
    case_0 = 3*log(sigma_0) - 2*log(sigma_0_prop) - log(sigma_1) - sqrt(sigma_0_prop/sigma_1) + sqrt(sigma_1/sigma_0)
  } else if (sigma_0 > sigma_1 && sigma_0_prop > sigma_1) {
    case_0 = 2*(log(sigma_0)-sigma_0_prop) -sqrt(sigma_0_prop/sigma_1) + sqrt(sigma_0/sigma_1)
  } else if (sigma_0 > sigma_1 && sigma_0_prop < sigma_1) {
    case_0 = 2*log(sigma_0) + log(sigma_1) - 3*log(sigma_0_prop) - sqrt(sigma_1/sigma_0_prop) + sqrt(sigma_0/sigma_1)
  }
  qfratio_0 = case_0
  alpha = min(0,qfratio_0)
  u = log(runif(1))
  if (u < alpha) {
    sigma_0 = sigma_0_prop
  }
  return(sigma_0)
}
```

```{r}
#Acceptance probability for sigma_1
# a_1 = 2.5
# b_1 = 6

sigmaone <- function(a_1, b_1, N_1, mu_0, mu_1, sigma_0, sigma_1){
  sigma_1squared_prop = rinvgamma(1, shape = a_1 + N_1/2, scale = 1/(1 + sum((y[x==1]-mu_1)^2)/2))
  sigma_1_prop = sqrt(sigma_1squared_prop)
  #logomega_1 = (2*a_1+1)*(log(sigma_1_prop)-log(sigma_1)) + b_1*(1/sigma_1_prop^2 - 1/sigma_1^2) - (mu_1-mu_0)/(sqrt(sigma_0*sigma_1_prop)) + (mu_1-mu_0)/(sqrt(sigma_0*sigma_1))
  if (sigma_0 <= sigma_1_prop && sigma_0 <= sigma_1) {
    case_1 = 2*(log(sigma_1)-log(sigma_1_prop)) - sqrt(sigma_1_prop/sigma_0) + sqrt(sigma_1/sigma_0)
  } else if (sigma_0 <= sigma_1_prop && sigma_0 > sigma_1) {
    case_1 = 3*log(sigma_1) - log(sigma_0) - 2*log(sigma_1_prop) - sqrt(sigma_1_prop/sigma_0) + sqrt(sigma_0/sigma_1)
  } else if (sigma_0 > sigma_1_prop && sigma_0 > sigma_1) {
    case_1 = 3*(log(sigma_1)-log(sigma_1_prop)) - sqrt(sigma_0/sigma_1_prop) + sqrt(sigma_0/sigma_1)
  } else if (sigma_0 > sigma_1_prop && sigma_0 <= sigma_1) {
    case_1 = log(sigma_0) + 2*log(sigma_1) - 3*log(sigma_1_prop) - sqrt(sigma_0/sigma_1_prop) + sqrt(sigma_1/sigma_0)
  }
  qfratio_1 = case_1
  alpha = min(0,qfratio_1)
  u = log(runif(1))
  if (u < alpha) {
    sigma_1 = sigma_1_prop
  }
  return(sigma_1)
}
```

```{r}
# Updating x and parameters
numruns <- 400

#Initialize
#y = read.table("./image.txt", header = FALSE, sep = " ")
y = matrix(scan("./image.txt", sep = " "), nrow = 85)
nrows = dim(y)[1]
ncolumns = dim(y)[2]
x = matrix(rbinom(nrows * ncolumns, 1, 0.5), ncol = ncolumns, nrow = nrows)
expvalsum <- matrix(0, nrows, ncolumns)
muzeros <- rep(0,numruns)
muones <- rep(0, numruns)
sigmazeros <- rep(0, numruns)
sigmaones <- rep(0, numruns)
N1_vec <- rep(0, numruns)

burn_in <- 250
if(numruns < burn_in){
  print("Stop and adjust burn in")
}

avg <- rep(0, numruns-burn_in)

mu_0 <- -1
sigma_0 <- 0.5
a_0 <- 3
b_0 <- 7

mu_1 <- 2
sigma_1 <- 0.5
a_1 <- 3
b_1 <- 7

beta <- 1

# Run algorithm
for (runs in 1:numruns) {
  xupdate <- x_update(89*85, x, mu_0, mu_1, sigma_0, sigma_1, beta)

  N_0 = sum(x==0)
  ysum0 = sum(y[x==0])
  # Update mu_0
  mu_0 <- muzero(N_0, ysum0, sigma_0, mu_0, mu_1)
  muzeros[runs] <- mu_0
  
  N_1 = sum(x==1)
  N1_vec[runs] <- N_1
  ysum1 = sum(y[x==1])
  #Update mu_1
  mu_1 <- muone(N_1, ysum1, sigma_1, mu_0, mu_1)
  muones[runs] <- mu_1
  
  # Update sigma_0, sigma_1
  sigma_0 <- sigmazero(a_0, b_0, N_0, mu_0, mu_1, sigma_0, sigma_1)
  sigmazeros[runs] <- sigma_0
  sigma_1 <- sigmaone(a_1, b_1, N_1, mu_0, mu_1, sigma_0, sigma_1)
  sigmaones[runs] <- sigma_1
  
  # Save only x after burn in
  x <- xupdate
  if (runs > burn_in){
    expvalsum <- expvalsum + x
    avg[runs-burn_in] <- mean(x) # Why?
  }
}
```



## 6 a)
```{r}
# Evaluation of properties of the algorithm 

# B.6.a)
# Expected value E[x_ij|y]
expvalsum <- expvalsum/(numruns-burn_in)
image(z = expvalsum)

# Posterior marginal most probable value for x_ij
# arg max f(x_ij|y)
xround <- round(expvalsum)
image(z = xround)
# Fraction of nodes where posterior most probable value x_ij = 1
fracnodes_post <- mean(xround)
print("Fraction of nodes where posterior most probable value x_{ij} = 1")
print(fracnodes_post)

#B.6.b)
# Expected fraction of nodes with x_{ij} = 1
fracnodes <- mean(avg) # sum(avg)/(numruns-burn_in)
# fracnodes <- mean(expvalsum)
print("Expected fraction of nodes with x_{ij} = 1")
print(fracnodes)
```



```{r}
# 5. Jens
# Plots of parameters
plot(1:numruns, muzeros)
plot(1:numruns, muones)
plot(1:numruns, sigmazeros)
plot(1:numruns, sigmaones)
# Plot of hov many nodes are equal to one in each iteration
plot(1:numruns, N1_vec)

```

## B.7.
```{r}
# a)
# Set \beta = 1
# Marginal distributions
truehist(muzeros[burn_in:numruns])
truehist(muones[burn_in:numruns])
truehist(sigmazeros[burn_in:numruns])
truehist(sigmaones[burn_in:numruns])


truehist(y[x==0])

#b)
# Variance of gamma & Confidence Interval
#variance <- var(avg)
variance <- var(fracnodes)
qtlower <- qt(0.05, 85*89-1)
qtupper <- qt(0.95, 85*89-1)
CI <- c(mean(fracnodes)+qtlower*variance, mean(fracnodes)+qtupper*variance)

# Credible interval
avg <- sort(avg)
print(quantile(average, c(0.05, 0.95)))
low <- round(0.05*(numruns-burn_in))
upp <- round(0.95*(numruns-burn_in))
credint <- c(average[low], average[upp]) 
print("Credible interval for x_ij == 1, 90%")
print(credint)


# Since variance is estimated, and expected value is 
```


